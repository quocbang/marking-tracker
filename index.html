<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; 
               font-src 'self' https://fonts.gstatic.com https://docs.google.com;
               frame-ancestors 'self' chrome-extension://*">
  <title>Dũng English Speaking</title>
  <link rel="icon" type="image/png" href="https://ssl.gstatic.com/docs/doclist/images/mediatype/icon_1_document_x16.png">
  <style>
    html,body,iframe{margin:0;padding:0;width:100%;height:100%} 
    iframe{border:none}
    
    /* Floating Action Button */
    .fab-container {
      position: fixed;
      bottom: 30px;
      right: 30px;
      z-index: 10000;
    }
    
    .fab-button {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      font-size: 24px;
      color: white;
    }
    
    .fab-button:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 16px rgba(0,0,0,0.4);
    }
    
    /* Hover Menu */
    .fab-menu {
      position: absolute;
      bottom: 65px;
      right: 0;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      padding: 16px 12px;
      min-width: 200px;
      opacity: 0;
      visibility: hidden;
      transform: translateY(10px);
      transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
      transition-delay: 0s;
      pointer-events: none;
    }
    
    /* Create invisible bridge between FAB and menu */
    .fab-menu::before {
      content: '';
      position: absolute;
      bottom: -15px;
      left: 0;
      right: 0;
      height: 20px;
      background: transparent;
    }
    
    .fab-container:hover .fab-menu {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
      pointer-events: auto;
      transition-delay: 0s;
    }
    
    /* Keep menu visible briefly when mouse leaves to allow movement */
    .fab-menu:hover {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
      pointer-events: auto;
    }
    
    .fab-menu-button {
      width: 100%;
      padding: 12px 16px;
      margin: 4px 0;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .btn-complete {
      background: #4CAF50;
      color: white;
    }
    
    .btn-complete:hover {
      background: #45a049;
      transform: translateX(-2px);
    }
    
    .btn-next {
      background: #2196F3;
      color: white;
    }
    
    .btn-next:hover {
      background: #1976D2;
      transform: translateX(-2px);
    }
    
    .btn-report {
      background: #ff5252;
      color: white;
    }
    
    .btn-report:hover {
      background: #e04848;
      transform: translateX(-2px);
    }
    
    /* Error Report Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 10001;
      align-items: center;
      justify-content: center;
    }
    
    .modal-overlay.active {
      display: flex;
    }
    
    .modal-content {
      background: white;
      border-radius: 12px;
      padding: 24px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      animation: modalSlideIn 0.3s ease;
    }
    
    @keyframes modalSlideIn {
      from {
        transform: translateY(-20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    .modal-header {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 16px;
      color: #333;
    }
    
    .modal-body {
      margin-bottom: 20px;
    }
    
    .modal-label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
      color: #666;
      font-weight: 500;
    }
    
    .modal-select {
      width: 100%;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 14px;
      font-family: Arial, sans-serif;
      transition: border-color 0.2s ease;
      box-sizing: border-box;
      background: white;
      cursor: pointer;
    }
    
    .modal-select:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .modal-textarea {
      width: 100%;
      min-height: 120px;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 14px;
      font-family: Arial, sans-serif;
      resize: vertical;
      transition: border-color 0.2s ease;
      box-sizing: border-box;
    }
    
    .modal-textarea:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .modal-footer {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }
    
    .modal-button {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .btn-cancel {
      background: #f5f5f5;
      color: #666;
    }
    
    .btn-cancel:hover {
      background: #e0e0e0;
    }
    
    .btn-submit {
      background: #667eea;
      color: white;
    }
    
    .btn-submit:hover {
      background: #5568d3;
    }
    
    .btn-submit:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <iframe id="docFrame"></iframe>

  <!-- Floating Action Button -->
  <div class="fab-container">
    <button class="fab-button" title="Menu">
      ⚙️
    </button>
    <div class="fab-menu">
      <button class="fab-menu-button btn-complete" id="completeBtn">
        ✓ Hoàn Thành
      </button>
      <button class="fab-menu-button btn-next" id="nextBtn">
        → Tiếp theo
      </button>
      <button class="fab-menu-button btn-report" id="reportBtn">
        ⚠ Báo lỗi
      </button>
    </div>
  </div>

  <!-- Error Report Modal -->
  <div class="modal-overlay" id="errorModal">
    <div class="modal-content">
      <div class="modal-header">Báo cáo lỗi</div>
      <div class="modal-body">
        <label class="modal-label" for="errorType">Loại lỗi:</label>
        <select class="modal-select" id="errorType">
          <option value="">-- Chọn loại lỗi --</option>
          <option value="session_lost">Lỗi hệ thống - Session bị mất</option>
          <option value="network_error">Lỗi mạng - Không gửi được heartbeat</option>
          <option value="ui_lag">Giao diện lag/đơ</option>
          <option value="doc_not_load">Google Doc không load được</option>
          <option value="button_not_work">Nút Hoàn Thành không hoạt động</option>
          <option value="other">Khác (vui lòng mô tả)</option>
        </select>
        
        <label class="modal-label" for="errorDescription" style="margin-top: 16px;">
          Mô tả chi tiết <span id="optionalLabel">(tuỳ chọn)</span>:
        </label>
        <textarea 
          class="modal-textarea" 
          id="errorDescription" 
          placeholder="Mô tả thêm về lỗi nếu cần..."
          style="min-height: 80px;"
        ></textarea>
      </div>
      <div class="modal-footer">
        <button class="modal-button btn-cancel" id="cancelBtn">Hủy</button>
        <button class="modal-button btn-submit" id="submitBtn">Gửi báo cáo</button>
      </div>
    </div>
  </div>

<script>
(async function(){
  const params = new URLSearchParams(window.location.search);
  const name = params.get('name') || 'unknown';
  const docUrl = params.get('doc');
  const speaking = params.get('speaking');
  const type = docUrl ? 'writing' : speaking ? 'speaking' : null;
  if(!docUrl && !speaking) { document.body.innerHTML = '<h3>Missing ?doc= or ?speaking= param</h3>'; return; }

  const BACKEND = 'https://n8n.dungenglishspeaking.com/webhook/marking-log';
  const START_URL = BACKEND + '/start';
  const HB_URL = BACKEND + '/heartbeat';
  const END_URL = BACKEND + '/end';
  const ERRORS_URL = BACKEND + '/errors';

  const iframe = document.getElementById('docFrame');
  if (docUrl) {
    iframe.src = docUrl;
  } else if (speaking) {
    iframe.src = speaking;
  }

  // Extract document ID from URL to create document-specific localStorage key
  // This ensures each document has its own session, allowing teachers to grade multiple documents
  const docId = (() => {
    if (docUrl) {
      try {
        const url = new URL(docUrl);
        // Extract doc ID from Google Docs URL (e.g., /document/d/DOC_ID/edit)
        const pathParts = url.pathname.split('/');
        const dIndex = pathParts.indexOf('d');
        return dIndex >= 0 && pathParts[dIndex + 1] ? pathParts[dIndex + 1] : 'unknown';
      } catch(e) {
        // Fallback: use simple hash of docUrl
        return btoa(docUrl).slice(0, 16).replace(/[^a-zA-Z0-9]/g, '');
      }
    } else if (speaking) {
      // For speaking mode, use speaking param as identifier
      return 'speaking_' + speaking.replace(/[^a-zA-Z0-9]/g, '_');
    } else {
      return 'unknown';
    }
  })();
  const LS_KEY = `grading_session_${docId}`;
  
  // Flag to track if user is intentionally leaving (not just reloading)
  let isIntentionalExit = false;
  
  // Flag to prevent sending /end multiple times
  let endSent = false;

  // try to reuse session from localStorage
  let session = null;
  try { session = JSON.parse(localStorage.getItem(LS_KEY)); } catch(e){ session = null; }

  // helper: call backend - returns { ok: boolean, data: object, status: number, errorCode?: string }
  async function postJson(url, body) {
    try {
      const res = await fetch(url, {
        method:'POST',
        headers:{ 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
        credentials: 'omit',
      });
      const data = res.ok ? await res.json().catch(()=>null) : await res.json().catch(()=>null);
      return {
        ok: res.ok,
        status: res.status,
        data: data,
        errorCode: data && data.error_code ? data.error_code : null
      };
    } catch(e){
      console.warn('post error', e);
      return { ok: false, status: 0, data: null, errorCode: null };
    }
  }

  // create new session if none or expired
  async function ensureSession(forceNew = false) {
    // Check if we have a valid session in localStorage (unless forcing new)
    if (!forceNew && session && session.sessionId && session.expiresAt && Date.now() < session.expiresAt) {
      console.log('Reusing existing session:', session.sessionId);
      return session;
    }
    
    // Create new session - retry until successful
    console.log(forceNew ? 'Creating new session (forced)...' : 'Creating new session...');
    const payload = { name, docUrl, type };
    
    let attempts = 0;
    const maxAttempts = 10;
    const retryDelay = 2000; // 2 seconds between retries
    
    while (attempts < maxAttempts) {
      attempts++;
      console.log(`Session creation attempt ${attempts}/${maxAttempts}...`);
      
      const res = await postJson(START_URL, payload);
      
      if (res.ok && res.data && res.data.sessionId) {
        // Successfully created session
        session = {
          sessionId: res.data.sessionId,
          createdAt: Date.now(),
          expiresAt: Date.now() + (res.data.ttlMs || 4*60*60*1000)
        };
        localStorage.setItem(LS_KEY, JSON.stringify(session));
        console.log('New session created:', session.sessionId);
        return session;
      } else {
        // Log error and retry
        const errorMsg = res.data && res.data.message ? res.data.message : 'Unknown error';
        const errorCode = res.errorCode || 'UNKNOWN';
        console.warn(`Session creation failed (${errorCode}): ${errorMsg}`);
        
        if (attempts < maxAttempts) {
          console.log(`Retrying in ${retryDelay/1000} seconds...`);
          await new Promise(resolve => setTimeout(resolve, retryDelay));
        }
      }
    }
    
    // Failed after all attempts
    console.error('Failed to create session after maximum attempts');
    document.body.innerHTML = '<div style="padding:20px;font-family:Arial"><h2>Unable to start session</h2><p>Failed to connect to the tracking system after multiple attempts. Please check your connection and try refreshing the page.</p></div>';
    throw new Error('Failed to create session');
  }

  // heartbeat loop (every 5s)
  let hbTimer = null;
  let lastActivityTs = Date.now();

  // consider user active on these events
  ['mousemove','keydown','click','scroll','touchstart'].forEach(evt=>{
    window.addEventListener(evt, ()=>{ lastActivityTs = Date.now(); });
  });

  // Track tab focus (when user switches back to this tab)
  window.addEventListener('focus', ()=>{ lastActivityTs = Date.now(); });
  
  // Track visibility change (when tab becomes visible)
  document.addEventListener('visibilitychange', ()=>{
    if (!document.hidden) lastActivityTs = Date.now();
  });

  // Track iframe focus (when user clicks into Google Doc)
  iframe.addEventListener('load', ()=>{
    try {
      // Try to add focus listener after iframe loads
      iframe.contentWindow.addEventListener('focus', ()=>{ lastActivityTs = Date.now(); }, true);
    } catch(e) {
      // If cross-origin, fallback to just tracking iframe element focus
      console.log('Cannot track iframe content focus (cross-origin), using iframe element focus');
    }
  });
  
  // Also track when iframe element itself receives focus
  iframe.addEventListener('focus', ()=>{ lastActivityTs = Date.now(); });

  await ensureSession();

  async function sendHeartbeat() {  
    if (!session) return;
    const body = { sessionId: session.sessionId, ts: new Date().toISOString() };
    // include 'active' flag if user has recent activity (<45s)
    // Increased from 10s to 45s to account for reading/thinking time
    body.active = (Date.now() - lastActivityTs) < 45000;
    
    // Send heartbeat and handle SESSION_NOT_FOUND error
    const res = await postJson(HB_URL, body);
    
    // If session not found, create a new session and retry heartbeat
    if (!res.ok && res.errorCode === 'SESSION_NOT_FOUND') {
      console.log('Session not found on server, creating new session...');
      await ensureSession(true); // Force create new session
      // Retry heartbeat with new session
      if (session) {
        body.sessionId = session.sessionId;
        await postJson(HB_URL, body);
      }
    }
  }

  // start HB after ensuring session
  hbTimer = setInterval(sendHeartbeat, 5000);
  // send immediate first heartbeat (marks the session as active again after reload)
  sendHeartbeat().catch(()=>{});

  // End session only when truly leaving (not reloading)
  function endSession(reason = 'closed') {
    // Prevent duplicate calls
    if (endSent || !session) return;
    endSent = true;
    
    console.log('Ending session:', session.sessionId, 'reason:', reason);
    
    const payload = {
      sessionId: session.sessionId,
      reason,
      ts: new Date().toISOString(),
      fullUrl: window.location.href,
      name: name,
      type: type
    };
    
    // navigator.sendBeacon to increase chance of delivery on unload
    try {
      const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
      navigator.sendBeacon(END_URL, blob);
    } catch (e) {
      // fallback synchronous fetch (try best effort)
      const xhr = new XMLHttpRequest();
      xhr.open("POST", END_URL, false); // sync
      xhr.setRequestHeader("Content-Type", "application/json");
      try { xhr.send(JSON.stringify(payload)); } catch(e){ /* ignore */ }
    }
    
    // Clear local storage
    localStorage.removeItem(LS_KEY);
  }

  // Detect if user is truly leaving or just reloading
  window.addEventListener('beforeunload', (e) => {
    // Only end session if explicitly marked as intentional exit
    if (isIntentionalExit) {
      endSession('closed');
    }
    // For reload: don't end session, heartbeat will resume after page loads
  });

  // pagehide event as backup (more reliable on mobile/modern browsers)
  window.addEventListener('pagehide', (e) => {
    // Only end session if explicitly marked as intentional exit
    if (isIntentionalExit) {
      endSession('closed');
    }
  });

  // ===== Floating Action Button Logic =====
  
  // Check if session is already completed on page load
  const completeBtn = document.getElementById('completeBtn');
  if (session && session.status === 'completed') {
    completeBtn.disabled = true;
    completeBtn.textContent = '✓ Đã hoàn thành';
    completeBtn.style.background = '#9e9e9e';
    completeBtn.style.cursor = 'not-allowed';
    console.log('Session already completed, button disabled');
  }
  
  // Next Button Handler
  const nextBtn = document.getElementById('nextBtn');
  nextBtn.addEventListener('click', async () => {
    // Disable button to prevent double-click
    nextBtn.disabled = true;
    nextBtn.textContent = 'Đang tải...';
    
    try {
      // Call /next-result API with name parameter
      const response = await fetch(`${BACKEND}/next-result?name=${encodeURIComponent(name)}`);
      
      if (!response.ok) {
        throw new Error(`API returned ${response.status}`);
      }
      
      const data = await response.json();
      
      // Check if URL is provided in response
      if (data.url) {
        console.log('Redirecting to next result:', data.url);
        // Mark as intentional exit before redirect
        isIntentionalExit = true;
        // End current session
        endSession('next_result');
        // Redirect to next URL
        window.location.href = data.url;
      } else {
        throw new Error('No URL provided in response');
      }
    } catch (e) {
      console.error('Failed to get next result:', e);
      alert('Không thể tải bài tiếp theo. Vui lòng thử lại.');
      nextBtn.disabled = false;
      nextBtn.textContent = '→ Tiếp theo';
    }
  });

  // Complete Button Handler
  completeBtn.addEventListener('click', async () => {
    if (confirm('Bạn có chắc chắn muốn hoàn thành phiên chấm điểm này không?')) {
      // Disable button to prevent double-click
      const completeBtn = document.getElementById('completeBtn');
      completeBtn.disabled = true;
      completeBtn.textContent = 'Đang xử lý...';
      
      try {
        // Mark as intentional exit
        isIntentionalExit = true;
        
        // Call /end API endpoint with proper fetch
        if (session && session.sessionId) {
          const payload = {
            sessionId: session.sessionId,
            reason: 'finished',
            ts: new Date().toISOString(),
            fullUrl: window.location.href,
            name: name,
            type: type
          };
          
          console.log('Calling /end API:', payload);
          const res = await postJson(END_URL, payload);
          
          if (res.ok) {
            console.log('Session ended successfully');
            
            // Update session status to completed in localStorage
            session.status = 'completed';
            session.completedAt = Date.now();
            localStorage.setItem(LS_KEY, JSON.stringify(session));
            
            // Stop heartbeat
            if (hbTimer) clearInterval(hbTimer);
            endSent = true;
            
            // Check if there's a nextLink in the response
            if (res.data && res.data.nextLink) {
              console.log('Redirecting to next link:', res.data.nextLink);
              // Keep button disabled and update text
              completeBtn.textContent = '✓ Đã hoàn thành - Chuyển tiếp...';
              completeBtn.style.background = '#4CAF50';
              // Redirect to next link
              window.location.href = res.data.nextLink;
              return; // Exit early to prevent further processing
            }
            
            // Keep button disabled and update text
            completeBtn.textContent = '✓ Đã hoàn thành';
            completeBtn.style.background = '#9e9e9e';
            completeBtn.style.cursor = 'not-allowed';
            
            alert('Đã hoàn thành phiên chấm điểm!');
          } else {
            console.error('Failed to end session:', res);
            alert('Có lỗi khi kết thúc phiên. Vui lòng thử lại.');
            completeBtn.disabled = false;
            completeBtn.textContent = '✓ Hoàn Thành';
            isIntentionalExit = false;
          }
        } else {
          alert('Không tìm thấy session để kết thúc.');
          completeBtn.disabled = false;
          completeBtn.textContent = '✓ Hoàn Thành';
        }
      } catch (e) {
        console.error('Error completing session:', e);
        alert('Có lỗi xảy ra. Vui lòng thử lại.');
        completeBtn.disabled = false;
        completeBtn.textContent = '✓ Hoàn Thành';
        isIntentionalExit = false;
      }
    }
  });

  // Report Error Modal Logic
  const modal = document.getElementById('errorModal');
  const reportBtn = document.getElementById('reportBtn');
  const cancelBtn = document.getElementById('cancelBtn');
  const submitBtn = document.getElementById('submitBtn');
  const errorType = document.getElementById('errorType');
  const errorDescription = document.getElementById('errorDescription');
  const optionalLabel = document.getElementById('optionalLabel');

  // Error type labels mapping (will be populated from API)
  let errorTypeLabels = {};
  let errorReasonsLoaded = false;

  // Fetch error reasons from API
  async function loadErrorReasons() {
    try {
      const response = await fetch(ERRORS_URL);
      if (!response.ok) {
        throw new Error('Failed to fetch error reasons');
      }
      const data = await response.json();
      // Clear existing options except the first one
      errorType.innerHTML = '<option value="">-- Chọn loại lỗi --</option>';
      // Populate dropdown with reasons from API
      if (data.reasons && Array.isArray(data.reasons)) {
        data.reasons.forEach(reason => {
          const option = document.createElement('option');
          option.value = reason.value || reason.label.toLowerCase().replace(/\s+/g, '_');
          option.textContent = reason.label;
          errorType.appendChild(option);
          // Store label mapping
          errorTypeLabels[option.value] = reason.label;
        });
        errorReasonsLoaded = true;
        console.log('Error reasons loaded from API:', data.reasons.length);
      }
    } catch (e) {
      console.error('Failed to load error reasons:', e);
      // Fallback to hardcoded options if API fails
      errorType.innerHTML = `
        <option value="">-- Chọn loại lỗi --</option>
        <option value="session_lost">Lỗi hệ thống - Session bị mất</option>
        <option value="network_error">Lỗi mạng - Không gửi được heartbeat</option>
        <option value="ui_lag">Giao diện lag/đơ</option>
        <option value="doc_not_load">Google Doc không load được</option>
        <option value="button_not_work">Nút Hoàn Thành không hoạt động</option>
        <option value="other">Khác (vui lòng mô tả)</option>
      `;
      errorTypeLabels = {
        'session_lost': 'Lỗi hệ thống - Session bị mất',
        'network_error': 'Lỗi mạng - Không gửi được heartbeat',
        'ui_lag': 'Giao diện lag/đơ',
        'doc_not_load': 'Google Doc không load được',
        'button_not_work': 'Nút Hoàn Thành không hoạt động',
        'other': 'Khác'
      };
      console.log('Using fallback error reasons');
    }
  }

  // Load error reasons on page load
  loadErrorReasons();

  // Handle error type change - make description required if "other" selected
  errorType.addEventListener('change', () => {
    if (errorType.value === 'other') {
      optionalLabel.textContent = '(bắt buộc)';
      optionalLabel.style.color = '#ff5252';
      errorDescription.setAttribute('required', 'required');
    } else {
      optionalLabel.textContent = '(tuỳ chọn)';
      optionalLabel.style.color = '#666';
      errorDescription.removeAttribute('required');
    }
  });

  // Open modal
  reportBtn.addEventListener('click', () => {
    modal.classList.add('active');
    errorType.value = '';
    errorDescription.value = '';
    optionalLabel.textContent = '(tuỳ chọn)';
    optionalLabel.style.color = '#666';
    errorDescription.removeAttribute('required');
  });

  // Close modal
  cancelBtn.addEventListener('click', () => {
    modal.classList.remove('active');
  });

  // Close modal when clicking outside
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      modal.classList.remove('active');
    }
  });

  // Submit error report
  submitBtn.addEventListener('click', async () => {
    const selectedType = errorType.value;
    const description = errorDescription.value.trim();
    
    // Validation
    if (!selectedType) {
      alert('Vui lòng chọn loại lỗi!');
      return;
    }
    
    if (selectedType === 'other' && !description) {
      alert('Vui lòng mô tả chi tiết lỗi khi chọn "Khác"!');
      return;
    }

    submitBtn.disabled = true;
    submitBtn.textContent = 'Đang gửi...';

    try {
      // Store error report in localStorage
      const errorReport = {
        sessionId: session ? session.sessionId : 'no-session',
        name: name,
        docUrl: docUrl,
        type: type,
        errorType: selectedType,
        errorTypeLabel: errorTypeLabels[selectedType] || selectedType,
        errorDescription: description || null,
        timestamp: new Date().toISOString()
      };

      // Save to localStorage
      const errorKey = `error_report_${Date.now()}`;
      localStorage.setItem(errorKey, JSON.stringify(errorReport));

      // Log to console for debugging
      console.log('Error Report:', errorReport);

      // Optional: Send to backend (you can add endpoint later)
      errorReport.fullUrl = window.location.href;
      const res = await postJson(ERRORS_URL, errorReport);
      if (res && res.data && res.data.nextLink) {
        // Redirect if nextLink is present
        window.location.href = res.data.nextLink;
        return;
      }
      alert('Đã gửi báo cáo lỗi thành công! Cảm ơn bạn đã phản hồi.');
      modal.classList.remove('active');
    } catch (e) {
      console.error('Failed to submit error report:', e);
      alert('Có lỗi xảy ra khi gửi báo cáo. Vui lòng thử lại.');
    } finally {
      submitBtn.disabled = false;
      submitBtn.textContent = 'Gửi báo cáo';
    }
  });

  // Allow Enter key to submit (with Ctrl/Cmd) - only for description textarea
  errorDescription.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
      submitBtn.click();
    }
  });

})();
</script>
</body>
</html>
