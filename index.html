<!doctype html>
<html>
<head>
  <meta charset="utf-8">  
  <title>Dũng English Speaking</title>
  <link rel="icon" type="image/png" href="https://ssl.gstatic.com/docs/doclist/images/mediatype/icon_1_document_x16.png">
  <style>
    html,body{margin:0;padding:0;width:100%;height:100%;font-family:Arial,sans-serif}

    /* Main Layout */
    .app-container {
      display: flex;
      width: 100%;
      height: 100vh;
      overflow: hidden;
    }

    /* Left Panel - Content Display */
    .content-panel {
      flex: 0 0 45%;
      background: #f8f9fa;
      border-right: 1px solid #e0e0e0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .content-header {
      padding: 16px 20px;
      background: #ffffff;
      border-bottom: 1px solid #e0e0e0;
      font-size: 16px;
      font-weight: 600;
      color: #333;
      flex-shrink: 0;
    }

    .content-body {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      line-height: 1.6;
      font-size: 14px;
      color: #333;
    }

    .content-placeholder {
      color: #666;
      font-style: italic;
      text-align: center;
      padding: 40px 20px;
    }

    /* Right Panel - Google Docs */
    .docs-panel {
      flex: 1;
      position: relative;
    }

    iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    /* Resizable Divider */
    .resize-divider {
      width: 8px;
      background: #f0f0f0;
      cursor: col-resize;
      position: relative;
      flex-shrink: 0;
      transition: background-color 0.2s ease;
      z-index: 10;
    }

    .resize-divider:hover {
      background: #e0e0e0;
    }

    .resize-divider:active {
      background: #d0d0d0;
    }

    .resize-handle {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 2px;
      height: 40px;
      background: #ccc;
      border-radius: 1px;
      opacity: 0.6;
      transition: opacity 0.2s ease;
    }

    .resize-divider:hover .resize-handle {
      opacity: 1;
    }

    /* Hide divider on mobile */
    @media (max-width: 768px) {
      .resize-divider {
        display: none;
      }
    }

    /* Resize overlay to prevent iframe interference */
    .resize-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 9999;
      cursor: col-resize;
      background: transparent;
      display: none;
    }

    /* Optimize panel for resizing */
    .content-panel {
      transition: none;
    }
    
    /* Floating Action Button */
    .fab-container {
      position: fixed;
      bottom: 30px;
      right: 30px;
      z-index: 10000;
    }
    
    .fab-button {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      font-size: 24px;
      color: white;
    }
    
    .fab-button:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 16px rgba(0,0,0,0.4);
    }
    
    /* Hover Menu */
    .fab-menu {
      position: absolute;
      bottom: 65px;
      right: 0;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      padding: 16px 12px;
      min-width: 200px;
      opacity: 0;
      visibility: hidden;
      transform: translateY(10px);
      transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
      transition-delay: 0s;
      pointer-events: none;
    }
    
    /* Create invisible bridge between FAB and menu */
    .fab-menu::before {
      content: '';
      position: absolute;
      bottom: -15px;
      left: 0;
      right: 0;
      height: 20px;
      background: transparent;
    }
    
    .fab-container:hover .fab-menu {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
      pointer-events: auto;
      transition-delay: 0s;
    }
    
    /* Keep menu visible briefly when mouse leaves to allow movement */
    .fab-menu:hover {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
      pointer-events: auto;
    }
    
    .fab-menu-button {
      width: 100%;
      padding: 12px 16px;
      margin: 4px 0;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .btn-complete {
      background: #4CAF50;
      color: white;
    }
    
    .btn-complete:hover {
      background: #45a049;
      transform: translateX(-2px);
    }
    
    .btn-next {
      background: #2196F3;
      color: white;
    }
    
    .btn-next:hover {
      background: #1976D2;
      transform: translateX(-2px);
    }
    
    .btn-report {
      background: #ff5252;
      color: white;
    }
    
    .btn-report:hover {
      background: #e04848;
      transform: translateX(-2px);
    }
    
    /* Error Report Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 10001;
      align-items: center;
      justify-content: center;
    }
    
    .modal-overlay.active {
      display: flex;
    }
    
    .modal-content {
      background: white;
      border-radius: 12px;
      padding: 24px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      animation: modalSlideIn 0.3s ease;
    }
    
    @keyframes modalSlideIn {
      from {
        transform: translateY(-20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    .modal-header {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 16px;
      color: #333;
    }
    
    .modal-body {
      margin-bottom: 20px;
    }
    
    .modal-label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
      color: #666;
      font-weight: 500;
    }
    
    .modal-select {
      width: 100%;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 14px;
      font-family: Arial, sans-serif;
      transition: border-color 0.2s ease;
      box-sizing: border-box;
      background: white;
      cursor: pointer;
    }
    
    .modal-select:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .modal-textarea {
      width: 100%;
      min-height: 120px;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 14px;
      font-family: Arial, sans-serif;
      resize: vertical;
      transition: border-color 0.2s ease;
      box-sizing: border-box;
    }
    
    .modal-textarea:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .modal-footer {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }
    
    .modal-button {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .btn-cancel {
      background: #f5f5f5;
      color: #666;
    }
    
    .btn-cancel:hover {
      background: #e0e0e0;
    }
    
    .btn-submit {
      background: #667eea;
      color: white;
    }
    
    .btn-submit:hover {
      background: #5568d3;
    }
    
    .btn-submit:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .app-container {
        flex-direction: column;
        height: auto;
      }

      .content-panel {
        flex: 0 0 auto;
        max-height: 40vh;
        border-right: none;
        border-bottom: 1px solid #e0e0e0;
      }

      .docs-panel {
        flex: 1;
        min-height: 60vh;
      }

      .fab-container {
        bottom: 20px;
        right: 20px;
      }

      .fab-button {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }

      .fab-menu {
        min-width: 180px;
        padding: 12px 8px;
      }

      .fab-menu-button {
        padding: 10px 12px;
        font-size: 13px;
      }
    }

    @media (max-width: 480px) {
      .content-panel {
        max-height: 35vh;
      }

      .docs-panel {
        min-height: 65vh;
      }

      .content-header {
        padding: 12px 16px;
        font-size: 14px;
      }

      .content-body {
        padding: 16px;
        font-size: 13px;
      }

      .fab-container {
        bottom: 15px;
        right: 15px;
      }

      .fab-button {
        width: 45px;
        height: 45px;
        font-size: 18px;
      }

      .fab-menu {
        min-width: 160px;
        padding: 10px 6px;
      }

      .fab-menu-button {
        padding: 8px 10px;
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Left Panel - Content Display -->
    <div class="content-panel">
      <div class="content-header">Nội dung bài tập</div>
      <div class="content-body" id="contentBody">
        <div class="content-placeholder">Đang tải nội dung...</div>
      </div>
    </div>

    <!-- Resizable Divider -->
    <div class="resize-divider" id="resizeDivider">
      <div class="resize-handle"></div>
    </div>

    <!-- Right Panel - Google Docs -->
    <div class="docs-panel">
      <iframe id="docFrame"></iframe>
    </div>
  </div>

  <!-- Floating Action Button -->
  <div class="fab-container">
    <button class="fab-button" title="Menu">
      ⚙️
    </button>
    <div class="fab-menu">
      <button class="fab-menu-button btn-complete" id="completeBtn">
        ✓ Hoàn Thành
      </button>
      <button class="fab-menu-button btn-next" id="nextBtn">
        → Tiếp theo
      </button>
      <button class="fab-menu-button btn-report" id="reportBtn">
        ⚠ Báo lỗi
      </button>
    </div>
  </div>

  <!-- Error Report Modal -->
  <div class="modal-overlay" id="errorModal">
    <div class="modal-content">
      <div class="modal-header">Báo cáo lỗi</div>
      <div class="modal-body">
        <label class="modal-label" for="errorType">Loại lỗi:</label>
        <select class="modal-select" id="errorType">
          <option value="">-- Chọn loại lỗi --</option>
          <option value="session_lost">Lỗi hệ thống - Session bị mất</option>
          <option value="network_error">Lỗi mạng - Không gửi được heartbeat</option>
          <option value="ui_lag">Giao diện lag/đơ</option>
          <option value="doc_not_load">Google Doc không load được</option>
          <option value="button_not_work">Nút Hoàn Thành không hoạt động</option>
          <option value="other">Khác (vui lòng mô tả)</option>
        </select>
        
        <label class="modal-label" for="errorDescription" style="margin-top: 16px;">
          Mô tả chi tiết <span id="optionalLabel">(tuỳ chọn)</span>:
        </label>
        <textarea 
          class="modal-textarea" 
          id="errorDescription" 
          placeholder="Mô tả thêm về lỗi nếu cần..."
          style="min-height: 80px;"
        ></textarea>
      </div>
      <div class="modal-footer">
        <button class="modal-button btn-cancel" id="cancelBtn">Hủy</button>
        <button class="modal-button btn-submit" id="submitBtn">Gửi báo cáo</button>
      </div>
    </div>
  </div>

<script>
(async function(){
  const params = new URLSearchParams(window.location.search);
  const name = params.get('name') || 'unknown';
  const docUrl = params.get('writing_url');
  const speaking = params.get('speaking');
  const type = docUrl ? 'writing' : speaking ? 'speaking' : null;
  if(!docUrl && !speaking) { document.body.innerHTML = '<h3>Missing ?writing_url= or ?speaking= param</h3>'; return; }

  const BACKEND = 'https://n8n.dungenglishspeaking.com/webhook/marking-log';
  const START_URL = BACKEND + '/start';
  const HB_URL = BACKEND + '/heartbeat';
  const END_URL = BACKEND + '/end';
  const ERRORS_URL = BACKEND + '/errors';

  const iframe = document.getElementById('docFrame');
  if (docUrl) {
    iframe.src = docUrl;
  } else if (speaking) {
    iframe.src = speaking;
  }

  // Extract document ID from URL to create document-specific localStorage key
  // This ensures each document has its own session, allowing teachers to grade multiple documents
  const docId = (() => {
    if (docUrl) {
      try {
        const url = new URL(docUrl);
        // Extract doc ID from Google Docs URL (e.g., /document/d/DOC_ID/edit)
        const pathParts = url.pathname.split('/');
        const dIndex = pathParts.indexOf('d');
        return dIndex >= 0 && pathParts[dIndex + 1] ? pathParts[dIndex + 1] : 'unknown';
      } catch(e) {
        // Fallback: use simple hash of docUrl
        return btoa(docUrl).slice(0, 16).replace(/[^a-zA-Z0-9]/g, '');
      }
    } else if (speaking) {
      // For speaking mode, use speaking param as identifier
      return 'speaking_' + speaking.replace(/[^a-zA-Z0-9]/g, '_');
    } else {
      return 'unknown';
    }
  })();
  const LS_KEY = `grading_session_${docId}`;
  
  // Flag to track if user is intentionally leaving (not just reloading)
  let isIntentionalExit = false;
  
  // Flag to prevent sending /end multiple times
  let endSent = false;

  // try to reuse session from localStorage
  let session = null;
  try { session = JSON.parse(localStorage.getItem(LS_KEY)); } catch(e){ session = null; }

  // helper: call backend - returns { ok: boolean, data: object, status: number, errorCode?: string }
  async function postJson(url, body) {
    try {
      const res = await fetch(url, {
        method:'POST',
        headers:{ 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
        credentials: 'omit',
      });
      const data = res.ok ? await res.json().catch(()=>null) : await res.json().catch(()=>null);
      return {
        ok: res.ok,
        status: res.status,
        data: data,
        errorCode: data && data.error_code ? data.error_code : null
      };
    } catch(e){
      console.warn('post error', e);
      return { ok: false, status: 0, data: null, errorCode: null };
    }
  }

  // create new session if none or expired
  async function ensureSession(forceNew = false) {
    // Check if we have a valid session in localStorage (unless forcing new)
    if (!forceNew && session && session.sessionId && session.expiresAt && Date.now() < session.expiresAt) {
      console.log('Reusing existing session:', session.sessionId);
      return session;
    }
    
    // Create new session - retry until successful
    console.log(forceNew ? 'Creating new session (forced)...' : 'Creating new session...');
    const payload = { name, docUrl, type };
    
    let attempts = 0;
    const maxAttempts = 10;
    const retryDelay = 2000; // 2 seconds between retries
    
    while (attempts < maxAttempts) {
      attempts++;
      console.log(`Session creation attempt ${attempts}/${maxAttempts}...`);
      
      const res = await postJson(START_URL, payload);
      
      if (res.ok && res.data && res.data.sessionId) {
        // Successfully created session
        session = {
          sessionId: res.data.sessionId,
          createdAt: Date.now(),
          expiresAt: Date.now() + (res.data.ttlMs || 4*60*60*1000),
          originalContent: res.data.original_content || null
        };
        localStorage.setItem(LS_KEY, JSON.stringify(session));
        console.log('New session created:', session.sessionId);
        return session;
      } else {
        // Log error and retry
        const errorMsg = res.data && res.data.message ? res.data.message : 'Unknown error';
        const errorCode = res.errorCode || 'UNKNOWN';
        console.warn(`Session creation failed (${errorCode}): ${errorMsg}`);
        
        if (attempts < maxAttempts) {
          console.log(`Retrying in ${retryDelay/1000} seconds...`);
          await new Promise(resolve => setTimeout(resolve, retryDelay));
        }
      }
    }
    
    // Failed after all attempts
    console.error('Failed to create session after maximum attempts');
    document.body.innerHTML = '<div style="padding:20px;font-family:Arial"><h2>Unable to start session</h2><p>Failed to connect to the tracking system after multiple attempts. Please check your connection and try refreshing the page.</p></div>';
    throw new Error('Failed to create session');
  }

  // heartbeat loop (every 5s)
  let hbTimer = null;
  let lastActivityTs = Date.now();

  // consider user active on these events
  ['mousemove','keydown','click','scroll','touchstart'].forEach(evt=>{
    window.addEventListener(evt, ()=>{ lastActivityTs = Date.now(); });
  });

  // Track tab focus (when user switches back to this tab)
  window.addEventListener('focus', ()=>{ lastActivityTs = Date.now(); });
  
  // Track visibility change (when tab becomes visible)
  document.addEventListener('visibilitychange', ()=>{
    if (!document.hidden) lastActivityTs = Date.now();
  });

  // Track iframe focus (when user clicks into Google Doc)
  iframe.addEventListener('load', ()=>{
    try {
      // Try to add focus listener after iframe loads
      iframe.contentWindow.addEventListener('focus', ()=>{ lastActivityTs = Date.now(); }, true);
    } catch(e) {
      // If cross-origin, fallback to just tracking iframe element focus
      console.log('Cannot track iframe content focus (cross-origin), using iframe element focus');
    }
  });
  
  // Also track when iframe element itself receives focus
  iframe.addEventListener('focus', ()=>{ lastActivityTs = Date.now(); });

  await ensureSession();

  // Function to fetch content from Google Docs URL via API
  async function fetchGoogleDocsContent(url) {
    try {
      console.log('Fetching content from Google Docs API:', url);

      // Use the dedicated API endpoint for fetching doc content
      const apiUrl = `https://n8n.dungenglishspeaking.com/webhook/marking-log/fetch-doc-content?writing_url=${encodeURIComponent(url)}`;

      const response = await fetch(apiUrl);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();

      if (data && data.original_content) {
        console.log('Successfully fetched content from Google Docs API');
        return data.original_content.trim();
      } else {
        console.warn('API response missing original_content');
        return null;
      }
    } catch (error) {
      console.warn('Failed to fetch from Google Docs API:', error);
      return null;
    }
  }

  // Function to display content - try Google Docs first, then API fallback
  async function displayContent() {
    const contentBody = document.getElementById('contentBody');

    try {
      // Show loading state
      contentBody.innerHTML = '<div class="content-placeholder">Đang tải nội dung...</div>';

      let content = null;

      // Try fetching from Google Docs first (only for writing mode)
      if (docUrl) {
        content = await fetchGoogleDocsContent(docUrl);
      }

      // If Google Docs fetch failed or not available, use API content
      if (!content && session && session.originalContent) {
        console.log('Using API content as fallback');
        content = session.originalContent;
      }

      // Display content or show error
      if (content) {
        contentBody.innerHTML = `<textarea id="contentTextarea" style="width: 100%; height: 100%; border: none; outline: none; resize: none; padding: 0; margin: 0; background: transparent; font-family: inherit; font-size: inherit; line-height: inherit; color: inherit; white-space: pre-wrap;">${content}</textarea>`;
        console.log('Content displayed successfully');
      } else {
        contentBody.innerHTML = '<div class="content-placeholder">Không thể tải nội dung bài tập</div>';
        console.warn('No content available from either source');
      }

    } catch (error) {
      console.error('Error displaying content:', error);
      contentBody.innerHTML = '<div class="content-placeholder">Lỗi khi tải nội dung</div>';
    }
  }

  // Display original content - try Google Docs first, then fallback to API
  displayContent();

  async function sendHeartbeat() {
    if (!session) return;
    const body = { sessionId: session.sessionId, ts: new Date().toISOString() };
    // include 'active' flag if user has recent activity (<45s)
    // Increased from 10s to 45s to account for reading/thinking time
    body.active = (Date.now() - lastActivityTs) < 45000;
    
    // Send heartbeat and handle SESSION_NOT_FOUND error
    const res = await postJson(HB_URL, body);
    
    // If session not found, create a new session and retry heartbeat
    if (!res.ok && res.errorCode === 'SESSION_NOT_FOUND') {
      console.log('Session not found on server, creating new session...');
      await ensureSession(true); // Force create new session
      // Retry heartbeat with new session
      if (session) {
        body.sessionId = session.sessionId;
        await postJson(HB_URL, body);
      }
    }
  }

  // start HB after ensuring session
  hbTimer = setInterval(sendHeartbeat, 5000);
  // send immediate first heartbeat (marks the session as active again after reload)
  sendHeartbeat().catch(()=>{});

  // End session only when truly leaving (not reloading)
  function endSession(reason = 'closed') {
    // Prevent duplicate calls
    if (endSent || !session) return;
    endSent = true;
    
    console.log('Ending session:', session.sessionId, 'reason:', reason);
    
    const payload = {
      sessionId: session.sessionId,
      reason,
      ts: new Date().toISOString(),
      fullUrl: window.location.href,
      name: name,
      type: type
    };
    
    // navigator.sendBeacon to increase chance of delivery on unload
    try {
      const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
      navigator.sendBeacon(END_URL, blob);
    } catch (e) {
      // fallback synchronous fetch (try best effort)
      const xhr = new XMLHttpRequest();
      xhr.open("POST", END_URL, false); // sync
      xhr.setRequestHeader("Content-Type", "application/json");
      try { xhr.send(JSON.stringify(payload)); } catch(e){ /* ignore */ }
    }
    
    // Clear local storage
    localStorage.removeItem(LS_KEY);
  }

  // Detect if user is truly leaving or just reloading
  window.addEventListener('beforeunload', (e) => {
    // Only end session if explicitly marked as intentional exit
    if (isIntentionalExit) {
      endSession('closed');
    }
    // For reload: don't end session, heartbeat will resume after page loads
  });

  // pagehide event as backup (more reliable on mobile/modern browsers)
  window.addEventListener('pagehide', (e) => {
    // Only end session if explicitly marked as intentional exit
    if (isIntentionalExit) {
      endSession('closed');
    }
  });

  // ===== Floating Action Button Logic =====
  
  // Check if session is already completed on page load
  const completeBtn = document.getElementById('completeBtn');
  if (session && session.status === 'completed') {
    completeBtn.disabled = true;
    completeBtn.textContent = '✓ Đã hoàn thành';
    completeBtn.style.background = '#9e9e9e';
    completeBtn.style.cursor = 'not-allowed';
    console.log('Session already completed, button disabled');
  }
  
  // Next Button Handler
  const nextBtn = document.getElementById('nextBtn');
  nextBtn.addEventListener('click', async () => {
    // Disable button to prevent double-click
    nextBtn.disabled = true;
    nextBtn.textContent = 'Đang tải...';
    
    try {
      // Call /next-result API with name parameter
      const response = await fetch(`${BACKEND}/next-result?name=${encodeURIComponent(name)}`);
      
      if (!response.ok) {
        throw new Error(`API returned ${response.status}`);
      }
      
      const data = await response.json();
      
      // Check if URL is provided in response
      if (data.url) {
        console.log('Redirecting to next result:', data.url);
        // Mark as intentional exit before redirect
        isIntentionalExit = true;
        // End current session
        endSession('next_result');
        // Redirect to next URL
        window.location.href = data.url;
      } else {
        throw new Error('No URL provided in response');
      }
    } catch (e) {
      console.error('Failed to get next result:', e);
      alert('Không thể tải bài tiếp theo. Vui lòng thử lại.');
      nextBtn.disabled = false;
      nextBtn.textContent = '→ Tiếp theo';
    }
  });

  // Complete Button Handler
  completeBtn.addEventListener('click', async () => {
    if (confirm('Bạn có chắc chắn muốn hoàn thành phiên chấm điểm này không?')) {
      // Disable button to prevent double-click
      const completeBtn = document.getElementById('completeBtn');
      completeBtn.disabled = true;
      completeBtn.textContent = 'Đang xử lý...';
      
      try {
        // Mark as intentional exit
        isIntentionalExit = true;
        
        // Call /end API endpoint with proper fetch
        if (session && session.sessionId) {
          const payload = {
            sessionId: session.sessionId,
            reason: 'finished',
            ts: new Date().toISOString(),
            fullUrl: window.location.href,
            name: name,
            type: type
          };
          
          console.log('Calling /end API:', payload);
          const res = await postJson(END_URL, payload);
          
          if (res.ok) {
            console.log('Session ended successfully');
            
            // Update session status to completed in localStorage
            session.status = 'completed';
            session.completedAt = Date.now();
            localStorage.setItem(LS_KEY, JSON.stringify(session));
            
            // Stop heartbeat
            if (hbTimer) clearInterval(hbTimer);
            endSent = true;
            
            // Check if there's a nextLink in the response
            if (res.data && res.data.nextLink) {
              console.log('Redirecting to next link:', res.data.nextLink);
              // Keep button disabled and update text
              completeBtn.textContent = '✓ Đã hoàn thành - Chuyển tiếp...';
              completeBtn.style.background = '#4CAF50';
              // Redirect to next link
              window.location.href = res.data.nextLink;
              return; // Exit early to prevent further processing
            }
            
            // Keep button disabled and update text
            completeBtn.textContent = '✓ Đã hoàn thành';
            completeBtn.style.background = '#9e9e9e';
            completeBtn.style.cursor = 'not-allowed';
            
            alert('Đã hoàn thành phiên chấm điểm!');
          } else {
            console.error('Failed to end session:', res);
            alert('Có lỗi khi kết thúc phiên. Vui lòng thử lại.');
            completeBtn.disabled = false;
            completeBtn.textContent = '✓ Hoàn Thành';
            isIntentionalExit = false;
          }
        } else {
          alert('Không tìm thấy session để kết thúc.');
          completeBtn.disabled = false;
          completeBtn.textContent = '✓ Hoàn Thành';
        }
      } catch (e) {
        console.error('Error completing session:', e);
        alert('Có lỗi xảy ra. Vui lòng thử lại.');
        completeBtn.disabled = false;
        completeBtn.textContent = '✓ Hoàn Thành';
        isIntentionalExit = false;
      }
    }
  });

  // Report Error Modal Logic
  const modal = document.getElementById('errorModal');
  const reportBtn = document.getElementById('reportBtn');
  const cancelBtn = document.getElementById('cancelBtn');
  const submitBtn = document.getElementById('submitBtn');
  const errorType = document.getElementById('errorType');
  const errorDescription = document.getElementById('errorDescription');
  const optionalLabel = document.getElementById('optionalLabel');

  // Error type labels mapping (will be populated from API)
  let errorTypeLabels = {};
  let errorReasonsLoaded = false;

  // Fetch error reasons from API
  async function loadErrorReasons() {
    try {
      const response = await fetch(ERRORS_URL);
      if (!response.ok) {
        throw new Error('Failed to fetch error reasons');
      }
      const data = await response.json();
      // Clear existing options except the first one
      errorType.innerHTML = '<option value="">-- Chọn loại lỗi --</option>';
      // Populate dropdown with reasons from API
      if (data.reasons && Array.isArray(data.reasons)) {
        data.reasons.forEach(reason => {
          const option = document.createElement('option');
          option.value = reason.value || reason.label.toLowerCase().replace(/\s+/g, '_');
          option.textContent = reason.label;
          errorType.appendChild(option);
          // Store label mapping
          errorTypeLabels[option.value] = reason.label;
        });
        errorReasonsLoaded = true;
        console.log('Error reasons loaded from API:', data.reasons.length);
      }
    } catch (e) {
      console.error('Failed to load error reasons:', e);
      // Fallback to hardcoded options if API fails
      errorType.innerHTML = `
        <option value="">-- Chọn loại lỗi --</option>
        <option value="session_lost">Lỗi hệ thống - Session bị mất</option>
        <option value="network_error">Lỗi mạng - Không gửi được heartbeat</option>
        <option value="ui_lag">Giao diện lag/đơ</option>
        <option value="doc_not_load">Google Doc không load được</option>
        <option value="button_not_work">Nút Hoàn Thành không hoạt động</option>
        <option value="other">Khác (vui lòng mô tả)</option>
      `;
      errorTypeLabels = {
        'session_lost': 'Lỗi hệ thống - Session bị mất',
        'network_error': 'Lỗi mạng - Không gửi được heartbeat',
        'ui_lag': 'Giao diện lag/đơ',
        'doc_not_load': 'Google Doc không load được',
        'button_not_work': 'Nút Hoàn Thành không hoạt động',
        'other': 'Khác'
      };
      console.log('Using fallback error reasons');
    }
  }

  // Load error reasons on page load
  loadErrorReasons();

  // Handle error type change - make description required if "other" selected
  errorType.addEventListener('change', () => {
    if (errorType.value === 'other') {
      optionalLabel.textContent = '(bắt buộc)';
      optionalLabel.style.color = '#ff5252';
      errorDescription.setAttribute('required', 'required');
    } else {
      optionalLabel.textContent = '(tuỳ chọn)';
      optionalLabel.style.color = '#666';
      errorDescription.removeAttribute('required');
    }
  });

  // Open modal
  reportBtn.addEventListener('click', () => {
    modal.classList.add('active');
    errorType.value = '';
    errorDescription.value = '';
    optionalLabel.textContent = '(tuỳ chọn)';
    optionalLabel.style.color = '#666';
    errorDescription.removeAttribute('required');
  });

  // Close modal
  cancelBtn.addEventListener('click', () => {
    modal.classList.remove('active');
  });

  // Close modal when clicking outside
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      modal.classList.remove('active');
    }
  });

  // Submit error report
  submitBtn.addEventListener('click', async () => {
    const selectedType = errorType.value;
    const description = errorDescription.value.trim();
    
    // Validation
    if (!selectedType) {
      alert('Vui lòng chọn loại lỗi!');
      return;
    }
    
    if (selectedType === 'other' && !description) {
      alert('Vui lòng mô tả chi tiết lỗi khi chọn "Khác"!');
      return;
    }

    submitBtn.disabled = true;
    submitBtn.textContent = 'Đang gửi...';

    try {
      // Store error report in localStorage
      const errorReport = {
        sessionId: session ? session.sessionId : 'no-session',
        name: name,
        docUrl: docUrl,
        type: type,
        errorType: selectedType,
        errorTypeLabel: errorTypeLabels[selectedType] || selectedType,
        errorDescription: description || null,
        timestamp: new Date().toISOString()
      };

      // Save to localStorage
      const errorKey = `error_report_${Date.now()}`;
      localStorage.setItem(errorKey, JSON.stringify(errorReport));

      // Log to console for debugging
      console.log('Error Report:', errorReport);

      // Optional: Send to backend (you can add endpoint later)
      errorReport.fullUrl = window.location.href;
      const res = await postJson(ERRORS_URL, errorReport);
      if (res && res.data && res.data.nextLink) {
        // Redirect if nextLink is present
        window.location.href = res.data.nextLink;
        return;
      }
      alert('Đã gửi báo cáo lỗi thành công! Cảm ơn bạn đã phản hồi.');
      modal.classList.remove('active');
    } catch (e) {
      console.error('Failed to submit error report:', e);
      alert('Có lỗi xảy ra khi gửi báo cáo. Vui lòng thử lại.');
    } finally {
      submitBtn.disabled = false;
      submitBtn.textContent = 'Gửi báo cáo';
    }
  });

  // Allow Enter key to submit (with Ctrl/Cmd) - only for description textarea
  errorDescription.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
      submitBtn.click();
    }
  });

  // ===== Resizable Divider Logic =====

  // Initialize panel width from localStorage or default
  const PANEL_WIDTH_KEY = 'panel_width_preference';
  let currentPanelWidth = parseFloat(localStorage.getItem(PANEL_WIDTH_KEY)) || 45; // Default 45%

  // Apply initial width
  const contentPanel = document.querySelector('.content-panel');
  contentPanel.style.flex = `0 0 ${currentPanelWidth}%`;

  const resizeDivider = document.getElementById('resizeDivider');
  let isResizing = false;
  let startX = 0;
  let startWidth = 0;
  let containerWidth = 0; // Cache container width
  let resizeOverlay = null; // Overlay element to prevent iframe interference

  // Create resize overlay element
  function createResizeOverlay() {
    if (resizeOverlay) return resizeOverlay;

    resizeOverlay = document.createElement('div');
    resizeOverlay.className = 'resize-overlay';
    document.body.appendChild(resizeOverlay);
    return resizeOverlay;
  }

  // Only enable resizing on desktop (screen width > 768px)
  function updateResizeCapability() {
    const isDesktop = window.innerWidth > 768;
    resizeDivider.style.display = isDesktop ? 'block' : 'none';

    if (isDesktop) {
      resizeDivider.addEventListener('mousedown', startResize);
      document.addEventListener('mousemove', resize);
      document.addEventListener('mouseup', stopResize);
    } else {
      resizeDivider.removeEventListener('mousedown', startResize);
      document.removeEventListener('mousemove', resize);
      document.removeEventListener('mouseup', stopResize);
    }
  }

  function startResize(e) {
    isResizing = true;
    startX = e.clientX;
    startWidth = currentPanelWidth;

    // Cache container width at start to avoid recalculating on every move
    const container = document.querySelector('.app-container');
    containerWidth = container.getBoundingClientRect().width;

    // Create and show overlay to prevent iframe interference
    createResizeOverlay();
    resizeOverlay.style.display = 'block';

    document.body.style.cursor = 'col-resize';
    document.body.style.userSelect = 'none';

    // Add will-change hint for smooth animation
    contentPanel.style.willChange = 'flex-basis';

    e.preventDefault();
  }

  function resize(e) {
    if (!isResizing) return;

    // Use cached container width and requestAnimationFrame for smooth updates
    const deltaX = e.clientX - startX;
    const deltaPercent = (deltaX / containerWidth) * 100;

    let newWidth = startWidth + deltaPercent;

    // Constrain width between 20% and 80%
    newWidth = Math.max(20, Math.min(80, newWidth));

    currentPanelWidth = newWidth;

    // Use requestAnimationFrame for smooth updates
    requestAnimationFrame(() => {
      contentPanel.style.flex = `0 0 ${newWidth}%`;
    });

    e.preventDefault();
  }

  function stopResize() {
    if (!isResizing) return;

    isResizing = false;

    // Hide overlay
    if (resizeOverlay) {
      resizeOverlay.style.display = 'none';
    }

    document.body.style.cursor = '';
    document.body.style.userSelect = '';

    // Remove will-change hint
    contentPanel.style.willChange = '';

    // Save preference to localStorage
    localStorage.setItem(PANEL_WIDTH_KEY, currentPanelWidth.toString());
    console.log('Panel width saved:', currentPanelWidth + '%');
  }

  // Initialize resize capability
  updateResizeCapability();

  // Update on window resize
  window.addEventListener('resize', updateResizeCapability);

})();
</script>
</body>
</html>
