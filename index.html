<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>DÅ©ng English Speaking</title>
  <link rel="icon" type="image/png" href="https://ssl.gstatic.com/docs/doclist/images/mediatype/icon_1_document_x16.png">
  <style>html,body,iframe{margin:0;padding:0;width:100%;height:100%} iframe{border:none}</style>
</head>
<body>
  <iframe id="docFrame"></iframe>

<script>
(async function(){
  const params = new URLSearchParams(window.location.search);
  const name = params.get('name') || 'unknown';
  const docUrl = params.get('doc');
  if(!docUrl) { document.body.innerHTML = '<h3>Missing ?doc= param</h3>'; return; }

  const BACKEND = 'https://n8n-mac.quocbangdev.asia/webhook/marking-log';
  const START_URL = BACKEND + '/start';
  const HB_URL = BACKEND + '/heartbeat';
  const END_URL = BACKEND + '/end';

  const iframe = document.getElementById('docFrame');
  iframe.src = docUrl;

  // localStorage key
  const LS_KEY = 'grading_session_v1';
  
  // Flag to track if user is intentionally leaving (not just reloading)
  let isIntentionalExit = false;

  // try to reuse session from localStorage
  let session = null;
  try { session = JSON.parse(localStorage.getItem(LS_KEY)); } catch(e){ session = null; }

  // helper: call backend
  async function postJson(url, body) {
    try {
      const res = await fetch(url, {
        method:'POST',
        headers:{ 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
        credentials: 'omit',
      });
      return res.ok ? await res.json().catch(()=>null) : null;
    } catch(e){
      console.warn('post error', e);
      return null;
    }
  }

  // create new session if none or expired
  async function ensureSession() {
    // Check if we have a valid session in localStorage
    if (session && session.sessionId && session.expiresAt && Date.now() < session.expiresAt) {
      console.log('Reusing existing session:', session.sessionId);
      return session;
    }
    
    // Create new session
    console.log('Creating new session...');
    const payload = { name, docUrl };
    const res = await postJson(START_URL, payload);
    if (res && res.sessionId) {
      // store session; expiresAt from server or default 4h
      session = {
        sessionId: res.sessionId,
        createdAt: Date.now(),
        expiresAt: Date.now() + (res.ttlMs || 4*60*60*1000)
      };
      localStorage.setItem(LS_KEY, JSON.stringify(session));
      console.log('New session created:', session.sessionId);
      return session;
    } else {
      // fallback: still create a local sessionId (less secure)
      const sid = 'local-' + Math.random().toString(36).slice(2,12);
      session = { sessionId: sid, createdAt: Date.now(), expiresAt: Date.now() + 60*60*1000 };
      localStorage.setItem(LS_KEY, JSON.stringify(session));
      console.log('Fallback session created:', session.sessionId);
      return session;
    }
  }

  // heartbeat loop (every 5s)
  let hbTimer = null;
  let lastActivityTs = Date.now();

  // consider user active on these events
  ['mousemove','keydown','click','scroll','touchstart'].forEach(evt=>{
    window.addEventListener(evt, ()=>{ lastActivityTs = Date.now(); });
  });

  // Track tab focus (when user switches back to this tab)
  window.addEventListener('focus', ()=>{ lastActivityTs = Date.now(); });
  
  // Track visibility change (when tab becomes visible)
  document.addEventListener('visibilitychange', ()=>{
    if (!document.hidden) lastActivityTs = Date.now();
  });

  // Track iframe focus (when user clicks into Google Doc)
  iframe.addEventListener('load', ()=>{
    try {
      // Try to add focus listener after iframe loads
      iframe.contentWindow.addEventListener('focus', ()=>{ lastActivityTs = Date.now(); }, true);
    } catch(e) {
      // If cross-origin, fallback to just tracking iframe element focus
      console.log('Cannot track iframe content focus (cross-origin), using iframe element focus');
    }
  });
  
  // Also track when iframe element itself receives focus
  iframe.addEventListener('focus', ()=>{ lastActivityTs = Date.now(); });

  await ensureSession();

  async function sendHeartbeat() {  
    if (!session) return;
    const body = { sessionId: session.sessionId, ts: new Date().toISOString() };
    // include 'active' flag if user has recent activity (<45s)
    // Increased from 10s to 45s to account for reading/thinking time
    body.active = (Date.now() - lastActivityTs) < 45000;
    // use fetch (regular) because frequent
    await postJson(HB_URL, body);
  }

  // start HB after ensuring session
  hbTimer = setInterval(sendHeartbeat, 5000);
  // send immediate first heartbeat (marks the session as active again after reload)
  sendHeartbeat().catch(()=>{});

  // End session only when truly leaving (not reloading)
  function endSession(reason = 'closed') {
    if (!session) return;
    console.log('Ending session:', session.sessionId, 'reason:', reason);
    
    const payload = {
      sessionId: session.sessionId,
      reason,
      ts: new Date().toISOString()
    };
    
    // navigator.sendBeacon to increase chance of delivery on unload
    try {
      const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
      navigator.sendBeacon(END_URL, blob);
    } catch (e) {
      // fallback synchronous fetch (try best effort)
      const xhr = new XMLHttpRequest();
      xhr.open("POST", END_URL, false); // sync
      xhr.setRequestHeader("Content-Type", "application/json");
      try { xhr.send(JSON.stringify(payload)); } catch(e){ /* ignore */ }
    }
    
    // Clear local storage
    localStorage.removeItem(LS_KEY);
  }

  // Detect if user is truly leaving or just reloading
  window.addEventListener('beforeunload', (e) => {
    // Only end session if explicitly marked as intentional exit
    if (isIntentionalExit) {
      endSession('closed');
    }
    // For reload: don't end session, heartbeat will resume after page loads
  });

  // Optional: Add a "Finish Grading" button
  // Uncomment this if you want an explicit finish button:
  /*
  const finishBtn = document.createElement('button');
  finishBtn.textContent = 'Finish Grading';
  finishBtn.style.cssText = 'position:fixed;top:10px;right:10px;z-index:9999;padding:10px 20px;background:#4CAF50;color:white;border:none;border-radius:4px;cursor:pointer;font-size:14px;';
  finishBtn.onclick = () => {
    isIntentionalExit = true;
    endSession('finished');
    alert('Grading session completed!');
    window.close(); // Try to close the window
  };
  document.body.appendChild(finishBtn);
  */

})();
</script>
</body>
</html>
