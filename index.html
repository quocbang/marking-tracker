<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>DÅ©ng English Speaking</title>
  <link rel="icon" type="image/png" href="https://ssl.gstatic.com/docs/doclist/images/mediatype/icon_1_document_x16.png">
  <style>html,body,iframe{margin:0;padding:0;width:100%;height:100%} iframe{border:none}</style>
</head>
<body>
  <iframe id="docFrame"></iframe>

<script>
(async function(){
  const params = new URLSearchParams(window.location.search);
  const name = params.get('name') || 'unknown';
  const docUrl = params.get('doc');
  if(!docUrl) { document.body.innerHTML = '<h3>Missing ?doc= param</h3>'; return; }

  const BACKEND = 'https://n8n-mac.quocbangdev.asia/webhook/marking-log';
  const START_URL = BACKEND + '/start';
  const HB_URL = BACKEND + '/heartbeat';
  const END_URL = BACKEND + '/end';

  const iframe = document.getElementById('docFrame');
  iframe.src = docUrl;

  // Extract document ID from URL to create document-specific localStorage key
  // This ensures each document has its own session, allowing teachers to grade multiple documents
  const docId = (() => {
    try {
      const url = new URL(docUrl);
      // Extract doc ID from Google Docs URL (e.g., /document/d/DOC_ID/edit)
      const pathParts = url.pathname.split('/');
      const dIndex = pathParts.indexOf('d');
      return dIndex >= 0 && pathParts[dIndex + 1] ? pathParts[dIndex + 1] : 'unknown';
    } catch(e) {
      // Fallback: use simple hash of docUrl
      return btoa(docUrl).slice(0, 16).replace(/[^a-zA-Z0-9]/g, '');
    }
  })();
  const LS_KEY = `grading_session_${docId}`;
  
  // Flag to track if user is intentionally leaving (not just reloading)
  let isIntentionalExit = false;
  
  // Flag to prevent sending /end multiple times
  let endSent = false;

  // try to reuse session from localStorage
  let session = null;
  try { session = JSON.parse(localStorage.getItem(LS_KEY)); } catch(e){ session = null; }

  // helper: call backend - returns { ok: boolean, data: object, status: number, errorCode?: string }
  async function postJson(url, body) {
    try {
      const res = await fetch(url, {
        method:'POST',
        headers:{ 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
        credentials: 'omit',
      });
      const data = res.ok ? await res.json().catch(()=>null) : await res.json().catch(()=>null);
      return {
        ok: res.ok,
        status: res.status,
        data: data,
        errorCode: data && data.error_code ? data.error_code : null
      };
    } catch(e){
      console.warn('post error', e);
      return { ok: false, status: 0, data: null, errorCode: null };
    }
  }

  // create new session if none or expired
  async function ensureSession(forceNew = false) {
    // Check if we have a valid session in localStorage (unless forcing new)
    if (!forceNew && session && session.sessionId && session.expiresAt && Date.now() < session.expiresAt) {
      console.log('Reusing existing session:', session.sessionId);
      return session;
    }
    
    // Create new session - retry until successful
    console.log(forceNew ? 'Creating new session (forced)...' : 'Creating new session...');
    const payload = { name, docUrl };
    
    let attempts = 0;
    const maxAttempts = 10;
    const retryDelay = 2000; // 2 seconds between retries
    
    while (attempts < maxAttempts) {
      attempts++;
      console.log(`Session creation attempt ${attempts}/${maxAttempts}...`);
      
      const res = await postJson(START_URL, payload);
      
      if (res.ok && res.data && res.data.sessionId) {
        // Successfully created session
        session = {
          sessionId: res.data.sessionId,
          createdAt: Date.now(),
          expiresAt: Date.now() + (res.data.ttlMs || 4*60*60*1000)
        };
        localStorage.setItem(LS_KEY, JSON.stringify(session));
        console.log('New session created:', session.sessionId);
        return session;
      } else {
        // Log error and retry
        const errorMsg = res.data && res.data.message ? res.data.message : 'Unknown error';
        const errorCode = res.errorCode || 'UNKNOWN';
        console.warn(`Session creation failed (${errorCode}): ${errorMsg}`);
        
        if (attempts < maxAttempts) {
          console.log(`Retrying in ${retryDelay/1000} seconds...`);
          await new Promise(resolve => setTimeout(resolve, retryDelay));
        }
      }
    }
    
    // Failed after all attempts
    console.error('Failed to create session after maximum attempts');
    document.body.innerHTML = '<div style="padding:20px;font-family:Arial"><h2>Unable to start session</h2><p>Failed to connect to the tracking system after multiple attempts. Please check your connection and try refreshing the page.</p></div>';
    throw new Error('Failed to create session');
  }

  // heartbeat loop (every 5s)
  let hbTimer = null;
  let lastActivityTs = Date.now();

  // consider user active on these events
  ['mousemove','keydown','click','scroll','touchstart'].forEach(evt=>{
    window.addEventListener(evt, ()=>{ lastActivityTs = Date.now(); });
  });

  // Track tab focus (when user switches back to this tab)
  window.addEventListener('focus', ()=>{ lastActivityTs = Date.now(); });
  
  // Track visibility change (when tab becomes visible)
  document.addEventListener('visibilitychange', ()=>{
    if (!document.hidden) lastActivityTs = Date.now();
  });

  // Track iframe focus (when user clicks into Google Doc)
  iframe.addEventListener('load', ()=>{
    try {
      // Try to add focus listener after iframe loads
      iframe.contentWindow.addEventListener('focus', ()=>{ lastActivityTs = Date.now(); }, true);
    } catch(e) {
      // If cross-origin, fallback to just tracking iframe element focus
      console.log('Cannot track iframe content focus (cross-origin), using iframe element focus');
    }
  });
  
  // Also track when iframe element itself receives focus
  iframe.addEventListener('focus', ()=>{ lastActivityTs = Date.now(); });

  await ensureSession();

  async function sendHeartbeat() {  
    if (!session) return;
    const body = { sessionId: session.sessionId, ts: new Date().toISOString() };
    // include 'active' flag if user has recent activity (<45s)
    // Increased from 10s to 45s to account for reading/thinking time
    body.active = (Date.now() - lastActivityTs) < 45000;
    
    // Send heartbeat and handle SESSION_NOT_FOUND error
    const res = await postJson(HB_URL, body);
    
    // If session not found, create a new session and retry heartbeat
    if (!res.ok && res.errorCode === 'SESSION_NOT_FOUND') {
      console.log('Session not found on server, creating new session...');
      await ensureSession(true); // Force create new session
      // Retry heartbeat with new session
      if (session) {
        body.sessionId = session.sessionId;
        await postJson(HB_URL, body);
      }
    }
  }

  // start HB after ensuring session
  hbTimer = setInterval(sendHeartbeat, 5000);
  // send immediate first heartbeat (marks the session as active again after reload)
  sendHeartbeat().catch(()=>{});

  // End session only when truly leaving (not reloading)
  function endSession(reason = 'closed') {
    // Prevent duplicate calls
    if (endSent || !session) return;
    endSent = true;
    
    console.log('Ending session:', session.sessionId, 'reason:', reason);
    
    const payload = {
      sessionId: session.sessionId,
      reason,
      ts: new Date().toISOString()
    };
    
    // navigator.sendBeacon to increase chance of delivery on unload
    try {
      const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
      navigator.sendBeacon(END_URL, blob);
    } catch (e) {
      // fallback synchronous fetch (try best effort)
      const xhr = new XMLHttpRequest();
      xhr.open("POST", END_URL, false); // sync
      xhr.setRequestHeader("Content-Type", "application/json");
      try { xhr.send(JSON.stringify(payload)); } catch(e){ /* ignore */ }
    }
    
    // Clear local storage
    localStorage.removeItem(LS_KEY);
  }

  // Detect if user is truly leaving or just reloading
  window.addEventListener('beforeunload', (e) => {
    // Only end session if explicitly marked as intentional exit
    if (isIntentionalExit) {
      endSession('closed');
    }
    // For reload: don't end session, heartbeat will resume after page loads
  });

  // pagehide event as backup (more reliable on mobile/modern browsers)
  window.addEventListener('pagehide', (e) => {
    // Only end session if explicitly marked as intentional exit
    if (isIntentionalExit) {
      endSession('closed');
    }
  });

  // Optional: Add a "Finish Grading" button
  // Uncomment this if you want an explicit finish button:
  /*
  const finishBtn = document.createElement('button');
  finishBtn.textContent = 'Finish Grading';
  finishBtn.style.cssText = 'position:fixed;top:10px;right:10px;z-index:9999;padding:10px 20px;background:#4CAF50;color:white;border:none;border-radius:4px;cursor:pointer;font-size:14px;';
  finishBtn.onclick = () => {
    isIntentionalExit = true;
    endSession('finished');
    alert('Grading session completed!');
    window.close(); // Try to close the window
  };
  document.body.appendChild(finishBtn);
  */

})();
</script>
</body>
</html>
